<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>data structure</title>
    <style type="text/css">
    *{
        margin: 0px;
        padding: 0px;
        box-sizing: border-box;
    }
    .nav{
        height: 80px;
        font-size: 18px;
        font-family: Arial, Helvetica, sans-serif;
        display: flex;
        align-items: center;
        background-color:#ffffff;
      }
      .home{
        margin-left: 5%;
        text-decoration: none;
      }
      .course{
        margin-left: 60px;
        text-decoration: none;
      }
      .student{
        margin-left: 60px;
        text-decoration: none;
      }
      .blogs{
        margin-left: 60px;
        text-decoration: none;
      }
      .place{
        margin-left: 60px;
        text-decoration: none;
      }
      .cont{
        margin-left: 60px;
        text-decoration: none;
      }
      .try{
        margin-left: 90px;
        border: 2px solid black;
        height: 30px;
        border-radius: 5px;
        padding-top: 5px;
        padding-left: 5px;
        padding-right: 5px;
        text-decoration: none;
      }
       .anchor:visited{
        color: black;
       }
       .try:hover{
        background-color: #07465d;
       }
       .container18{
        height: 850px;
       }
       .algo{
        position: relative;
        top: 20px;
        left: 20px;

       }
       .algo1{
        position: relative;
        top: 35px;
        left: 350px;

       }
       .algo2{
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        position: relative;
        top: 50px;
        left: 20px;
        line-height: 25px;
       }
       .type{
        height: 150px;
       }
       .type1{
        position: relative;
        top: 20px;
        left: 20px;
       }
       .type2{
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        line-height: 25px;
        position: relative;
        top: 30px;
        left: 20px;
       }
       .arrays{
        height: 370px;
       }
       .arr1{
        position: relative;
        top: 20px;
        left: 20px;

       }
       .arr2{
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        position: relative;
        top: 25px;
        left: 20px;
        line-height: 25px;

       }
       .arr3{
        position: relative;
        top: 30px;
        left: 20px;

       }
       .arr4{
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        position: relative;
        top: 30px;
        left: 20px;
        line-height: 25px;

       }
       .arr5{
        position: relative;
        top: 30px;
        left: 20px;

       }
       .arr6{
        font-family: Verdana, Geneva, Tahoma, sans-serif;
        position: relative;
        top: 30px;
        left: 20px;
        line-height: 25px;

       }
       .arr7{
        position: relative;
        top: 30px;
        left: 20px;

       }
       .arr8{
        font-family:Verdana, Geneva, Tahoma, sans-serif ;
        position: relative;
        top: 30px;
        left: 20px;
        line-height: 25px;
       }
       .stack{
        position: relative;
        top: 20px;
       }
       .trees{
        position: relative;
        top: 45px;
       }
       .graph{
        position: relative;
        top: 75px;
       }
       .follow{
        position: relative;
        top: 110px;

       }
       .employee{
        position: relative;
        top: 140px;
       }
       .search{
        position: relative;
        top: 170px;
       }
       .recursive{
        position: relative;
        top: 200px;
       }
       .greedy{
        position: relative;
        top: 230px;
       }
       .dynamic{
        position: relative;
        top: 260px;
       }
    </style>
    <link rel="icon" href="tap logo.png">
</head>
<body>
    <nav class="nav">
        <img src="7dqv1v4a.png" height="50px" width="120px">
        <a class="home anchor" href="index.html">Home</a>
        <a class="course anchor" href="course.html">Course</a>
        <a class="student anchor" href="student_review.html">Student Reviews</a>
        <a class="blogs anchor" href="blogs.html">Blogs</a>
        <a class="place anchor" href="placement.html">Placements</a>
        <a class="cont anchor" href="contact us.html">Contact Us</a>
        <a class="try anchor" href="contact us.html">Try for Free</a>
        </nav>
<div class="container18">
<div class="algo"><h1>What is Data Structure and Algorithm?</h1></div>
<div class="algo1"><img src="data structure pic.PNG"  height="400px" width="500px"></div>
<div class="algo2">
<p>You may already know that computers are used to store and modify massive amounts of data. Data structures are used to efficiently <br>
and conveniently arrange and store data. <br><br>
Organizing and storing data in a computer so that it can be accessed and used effectively is known as a data structure.In addition <br>
to defining the relationships between data pieces, it offers a means of representing and storing data. Common data structures include <br>
trees, stacks, queues, linked lists, arrays, and stacks. <br><br>
Now,an algorithm is a set of guidelines or procedures used to complete a task or solve a problem.To get a certain outcome,algorithms <br> 
are used to alter data that is stored in data structures. Data in an array or linked list can be sorted using a sorting algorithm, <br>
for instance. <br><br>
Data structures and algorithms are closely associated in computer science because an algorithmâ€™s effectiveness frequently depends <br> 
on the selection of an effective data structure. An algorithm can become more effective and quick with the right data format. For <br>
instance, a hash table is a popular data structure for quick data retrieval and searching.</p></div>
</div>
<div class="type">
<div class="type1"><h1>What are Data Structures and types?</h1></div>
<div class="type2">
<p>Data structures are specific methods for setting up and keeping data in a computer so that it may be accessed, changed, and searched<br>
quickly. There are many different kinds of data structures, and each has benefits and drawbacks that vary depending on the objectives<br>
of the application.</p></div>
</div>
<div class="arrays">
<div class="arr1"><h2>1. Arrays</h2></div>
<div class="arr2">
<p>Arrays are a type of data structure that keep a group of identically categorised elements in close proximity to one another in memory.<br> 
Despite having a fixed size, they can be ineffective for dynamic data or big datasets since they require constant-time access to <br>
individual items via an index.</p></div> 

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. Index-based constant-time access to individual elements <br>
2. For tiny, fixed-size data sets, effective <br>
3. Simple to use and understand </p></div>

<div class="arr5"><h3>Cons:</h3></div>
<div class="arr6">
<p>1. Uniform size <br>
2.Ineffective for large or dynamic data set </p></div>

<div class="arr7"><h3>Examples:</h3></div>
<div class="arr8">
<p>a list of contact details <br>
a list of test results</p></div>
</div>
<div class="list">
<div class="arr1"><h2>2. Linked Lists</h2></div>
<div class="arr2">
<p>Linked lists are a type of data structure that are made up of a series of nodes, each of which contains an element and a reference <br>
to the node after it in the list. They are distinguished by their speedy insert and delete of elements, but because of their <br>
non-contiguous memory allocation, their traversal may be slower than arrays.</p></div>

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. Effective element addition and deletion <br>
2. Varying size <br>
3. Memory-efficient </p></div>

<div class="arr5"><h3>Cons:</h3></div>
<div class="arr6">
<p>1. Traversing more slowly than arrays <br>
2. Less effective for gaining access to specific elements</p></div>

<div class="arr7"><h3>Examples:</h3></div>
<div class="arr8">
<p>a musical playlis <br>
books listed</p></div>
</div>
<div class="stack">
<div class="arr1"><h2>3. Stacks and Queues</h2></div>
<div class="arr2">
<p>Data structures used for handling a group of components include stacks and queues. The LIFO (last-in, first-out) ordering<br>
of stacks distinguishes them from queues, which are distinguished by the FIFO (first-in, first-out) ordering.</p></div> 

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. Easy to implement and comprehend <br>
2. Effective element addition and deletion</p></div>   

<div class="arr5"><h3>Cons:</h3></div>
<div class="arr6">
<p>1. Limited access to certain features <br>
2. Ineffective for sorting and searching </p></div>  

<div class="arr7"><h3>Examples:</h3></div>
<div class="arr8">
<p>In text editors, stacks can be utilized for the undo/redo capability. <br>
In a printer queue, queues can be used to manage print jobs.</p></div>
</div>
<div class="trees">
<div class="arr1"><h2>4. Trees</h2></div>
<div class="arr2">
<p>Trees are a type of hierarchical data structure that is made up of nodes and edges. There is one node known as the root <br>
that has no parents, and each node can have one or more children. The ability to efficiently explore and arrange data in a <br>
hierarchical fashion is a characteristic of trees.</p></div> 

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. Effective data sorting and searching<br>
2. Useful for displaying hierarchical relationships </p></div> 

<div class="arr5"><h3>Cons:</h3></div>
<div class="arr6">
<p>1. Unable to handle dynamic data <br>
2. Difficult to implement and comprehend Examples</p></div> 

<div class="arr7"><h3>Examples:</h3></div>
<div class="arr8">
<p>The computerâ€™s file system <br>
A companyâ€™s organizational chart </p></div>
</div>
<div class="graph">
<div class="arr1"><h2>5. Graphs:</h2></div>
<div class="arr2">
<p>A graph is a data structure made up of nodes (vertices) and the connections between them (edges). They are useful for <br>
modelling networks, social media connections, and a variety of other tasks because they can depict intricate interconnections <br>
between data.</p></div>

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. Modular and effective for simulating intricate interactions<br>
2. Can depict a variety of real-world scenarios.</p></div>

<div class="arr5"><h3>Cons:</h3></div>
<div class="arr6">
<p>1. Difficult to implement and comprehend <br>
2. Large data setsâ€™ search and sorting efficiency is poor</p></div>

<div class="arr7"><h3>Examples:</h3></div>
<div class="arr8">
<p>Using social media<br>
Road systems </p></div>
</div>
<div class="follow">
<div class="type1"><h1>What are Algorithms and types?</h1></div>
<div class="type2">
<p>Algorithms are a collection of instructions or rules that must be followed in order to complete a task or solve an issue. There <br>
are many different kinds of algorithms, and each has benefits and drawbacks that vary depending on the particular issue being solved.</p></div>  
</div>
<div class="employee">
<div class="arr1"><h2>1. Sorting Algorithms</h2></div>
<div class="arr2">
Sorting algorithms are employed to categorize and organize the elements of a list or an array. Several of the most popular sorting <br>
formulas include: <br>
1. Bubble Sort <br>
2. Selection Sort <br>
3. Insertion Sort <br>
4. Quick Sort <br>
5. Merge Sort  </p></div>

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. Able to sort huge datasets effectively <br>
2. Large-scale data analysis and search useful; can be tailored to meet certain requirements</p></div>

<div class="arr5"><h3>Cons:</h3></div>
<div>
<p class="arr6">1. For small datasets, some sorting techniques can be ineffective. <br>
2. Certain algorithms need more processing power or memory </p></div>
</div>
<div class="search">
<div class="arr1"><h2>2. Searching Algorithms</h2></div>
<div class="arr2">
<p>Searching Algorithms: are employed to locate a particular element in a list or an array. The following are some of the most popular <br>
search algorithms: <br>
a linear search iterates through the list element by element. <br>
Binary Search divides the list into two halves, compares the middle element with the target element, and then repeatedly searches the <br> 
relevant half of the list.</p></div>

<div class="arr3"><h3>Pros:</h3></div>
<div class="arr4">
<p>1. An effective search of big datasets<br>
2. Useful for locating specific list items <br>
3. Can be modified to meet particular demands</p></div>

<div class="arr5"><h3>Cons:</h3></div>
<div class="arr6">
<p>1. Certain search algorithms demand that the list be sorted first. <br>
2. If the required element is not present in the list, some algorithms may fail to find it.</p></div>
</div>
<div class="recursive">
<div class="arr1"><h2>3. Recursive Algorithms</h2></div>
<div class="arr2">
<p>Recursive algorithms are those that call themselves in order to solve a problem. They can be applied to a wide range of issues, <br> 
including search and sorting algorithms.</p></div>

<div class="arr3"><h3>Examples:</h3></div>

<div class="arr4"><p>Using the Fibonacci sequence to traverse a binary tree</p></div>

<div class="arr5"><h3>Pros:</h3></div>
<div class="arr6">
<p>1. Able to solve challenging issues<br>
2. Can some cases be more effective than non-recursive algorithms <br>
3. For some issues, it might be simpler to comprehend and put into practice.</p></div>

<div class="arr7"><h3>Cons:</h3></div>
<div class="arr8">
<p>1. Potentially memory-intensive compared to non-recursive algorithms <br>
2. May some circumstances be less effective than non-recursive algorithms</p></div>
</div>
<div class="greedy">
<div class="arr1"><h2>4. Greedy Algorithms</h2></div>
<div class="arr2">
<p>Greedy Algorithms: In order to achieve a globally optimal solution, greedy algorithms choose the locally optimal option at each step.<br> 
They are frequently employed for optimization issues.</p></div>

<div class="arr3"><h3>Examples:</h3></div>
<div class="arr4">
<p>The issue with coin exchange <br>
Dijkstraâ€™s shortest path algorithm </p></div>

<div class="arr5"><h3>Pros:</h3></div>
<div class="arr6">
<p>1. Able to solve problems fast<br>
2. Frequently offer accurate approximations to ideal answers<br>
3. Can be applied to a variety of issues</p></div>

<div class="arr7"><h3>Cons:</h3></div>
<div class="arr8">
<p>1. May not always come up with the worldâ€™s best answer <br>
2. It can be challenging to decide when a greedy algorithm is necessary.</p></div>
</div>
<div class="dynamic">
<div class="arr1"><h2>5. Dynamic Programming Algorithms</h2></div>
<div class="arr2">
<p>Algorithms for Dynamic Programming: Dynamic programming algorithms divide a problem into smaller subproblems and solve each <br>
subproblem just once. They can be more effective than brute force techniques and are frequently employed for optimization challenges.</p>  
</div>
<div class="arr3"><h3>Examples:</h3></div>
<div class="arr4">
<p>The issue with knapsacks<br>
Longest common sequence issue </p></div>

<div class="arr5"><h3>Pros:</h3></div>
<div class="arr6">
<p>1. Can effectively tackle complicated problems<br>
2. Can be applied to a variety of issues<br>
3. Frequently offer ideal answers </p></div>

<div class="arr7"><h3>Cons:</h3></div>

<div class="arr8"><p>1. Can be challenging to use and comprehend </p></div>
</div>
</body>
</html>